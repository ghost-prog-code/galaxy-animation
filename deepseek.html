<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Universe | Three.js Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
        
        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #8a2be2, #00bfff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
        }
        
        .subtitle {
            font-size: 1rem;
            font-weight: 300;
            letter-spacing: 2px;
            opacity: 0.8;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
            z-index: 100;
            padding: 0 20px;
        }
        
        #canvas-container {
            flex: 1;
            overflow: hidden;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            z-index: 200;
            color: #8a2be2;
            letter-spacing: 2px;
        }
        
        .progress-bar {
            width: 200px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #8a2be2, #00bfff);
            transition: width 0.3s ease;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            #instructions {
                font-size: 0.7rem;
                bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>GALAXY UNIVERSE</h1>
        <div class="subtitle">INTERACTIVE THREE.JS SIMULATION</div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="instructions">
        Move your mouse to influence the galaxies | Scroll to zoom
    </div>
    
    <div id="loading">
        <div>LOADING GALAXIES</div>
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main Three.js application
        class GalaxyUniverse {
            constructor() {
                // Configuration
                this.config = {
                    galaxyCount: 4,
                    particlesPerGalaxy: 5000,
                    mouseInfluence: 0.1,
                    mouseEasing: 0.05,
                    rotationSpeed: 0.1,
                    baseHue: 220,
                    hueRange: 60,
                    autoRotate: true,
                    bloomEnabled: true,
                    bloomStrength: 1.5,
                    bloomRadius: 0.4,
                    bloomThreshold: 0.8
                };
                
                // Core Three.js objects
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                // Galaxy system
                this.galaxies = [];
                this.particleSystems = [];
                
                // Mouse interaction
                this.mouse = { x: 0, y: 0, targetX: 0, targetY: 0 };
                this.targetCameraPosition = { x: 0, y: 0, z: 60 };
                
                // Animation
                this.frameCount = 0;
                this.clock = new THREE.Clock();
                
                // Performance
                this.fps = 60;
                this.lastFrameTime = 0;
                
                // Initialize the application
                this.init();
            }
            
            // Initialize the Three.js scene
            init() {
                this.setupScene();
                this.setupCamera();
                this.setupRenderer();
                this.setupGalaxies();
                this.setupEventListeners();
                this.hideLoadingScreen();
                this.animate();
            }
            
            // Set up the scene with background
            setupScene() {
                this.scene = new THREE.Scene();
                
                // Create a subtle gradient background
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const context = canvas.getContext('2d');
                
                // Create gradient
                const gradient = context.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, 0,
                    canvas.width / 2, canvas.height / 2, canvas.width / 2
                );
                gradient.addColorStop(0, 'rgba(5, 5, 20, 1)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(4, 4);
                
                this.scene.background = texture;
            }
            
            // Set up the camera
            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 2000);
                this.camera.position.set(0, 0, 60);
            }
            
            // Set up the WebGL renderer
            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setAnimationLoop(() => this.animate());
                
                // Enable tone mapping for better colors
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                
                // Add renderer to DOM
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
            }
            
            // Generate a spiral galaxy
            createGalaxy(index) {
                const particlesCount = this.config.particlesPerGalaxy;
                const positions = new Float32Array(particlesCount * 3);
                const colors = new Float32Array(particlesCount * 3);
                const sizes = new Float32Array(particlesCount);
                
                // Galaxy parameters
                const arms = 3 + Math.floor(Math.random() * 3); // 3-5 arms
                const armSpread = 0.5 + Math.random() * 0.3; // How tight the arms are
                const coreRadius = 2 + Math.random() * 3;
                const armLength = 15 + Math.random() * 10;
                const twist = 0.3 + Math.random() * 0.4;
                
                // Color variation
                const baseHue = (this.config.baseHue + (index * this.config.hueRange)) % 360;
                const hueVariation = 30;
                
                // Create particles in a spiral pattern
                for (let i = 0; i < particlesCount; i++) {
                    const i3 = i * 3;
                    
                    // Determine if particle is in core or arms
                    const isCore = Math.random() < 0.3;
                    
                    if (isCore) {
                        // Core particles - spherical distribution
                        const radius = coreRadius * Math.cbrt(Math.random());
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                        positions[i3 + 2] = radius * Math.cos(phi);
                        
                        // Core particles are brighter
                        const brightness = 0.7 + Math.random() * 0.3;
                        this.hslToRgb(baseHue / 360, 0.8, brightness, colors, i3);
                        
                        // Core particles are larger
                        sizes[i] = 1.5 + Math.random() * 1.5;
                    } else {
                        // Spiral arm particles
                        const armIndex = Math.floor(Math.random() * arms);
                        const angle = Math.random() * Math.PI * 2;
                        const distance = coreRadius + Math.random() * armLength;
                        
                        // Spiral formula
                        const spiralAngle = angle + (distance / armLength) * Math.PI * 2 * twist + (armIndex * Math.PI * 2 / arms);
                        
                        positions[i3] = Math.cos(spiralAngle) * distance;
                        positions[i3 + 1] = Math.sin(spiralAngle) * distance;
                        positions[i3 + 2] = (Math.random() - 0.5) * armSpread * distance;
                        
                        // Add some randomness to position
                        positions[i3] += (Math.random() - 0.5) * armSpread * 2;
                        positions[i3 + 1] += (Math.random() - 0.5) * armSpread * 2;
                        positions[i3 + 2] += (Math.random() - 0.5) * armSpread;
                        
                        // Arm particles color
                        const hue = (baseHue + (Math.random() - 0.5) * hueVariation) / 360;
                        const saturation = 0.6 + Math.random() * 0.3;
                        const brightness = 0.4 + Math.random() * 0.4;
                        this.hslToRgb(hue, saturation, brightness, colors, i3);
                        
                        // Size variation
                        sizes[i] = 0.5 + Math.random() * 1.5;
                    }
                }
                
                // Create geometry and material
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    sizeAttenuation: true
                });
                
                // Create the particle system
                const galaxy = new THREE.Points(geometry, material);
                
                // Position the galaxy in space
                const angle = (index / this.config.galaxyCount) * Math.PI * 2;
                const radius = 25;
                const height = (Math.random() - 0.5) * 15;
                
                galaxy.userData.originalPosition = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                galaxy.userData.rotationSpeed = {
                    x: (Math.random() - 0.5) * 0.01,
                    y: 0.02 + Math.random() * 0.02,
                    z: (Math.random() - 0.5) * 0.01
                };
                
                galaxy.userData.offset = Math.random() * Math.PI * 2;
                galaxy.position.copy(galaxy.userData.originalPosition);
                
                return galaxy;
            }
            
            // Set up all galaxies
            setupGalaxies() {
                for (let i = 0; i < this.config.galaxyCount; i++) {
                    const galaxy = this.createGalaxy(i);
                    this.scene.add(galaxy);
                    this.galaxies.push(galaxy);
                }
                
                // Add a few distant stars for depth
                this.addDistantStars();
            }
            
            // Add distant background stars
            addDistantStars() {
                const starCount = 2000;
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);
                const sizes = new Float32Array(starCount);
                
                for (let i = 0; i < starCount; i++) {
                    const i3 = i * 3;
                    
                    // Distant stars in a sphere
                    const radius = 80 + Math.random() * 120;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // Star colors (white to blue)
                    const colorValue = 0.7 + Math.random() * 0.3;
                    colors[i3] = colorValue;
                    colors[i3 + 1] = colorValue * 0.9;
                    colors[i3 + 2] = colorValue;
                    
                    // Size - distant stars are smaller
                    sizes[i] = 0.1 + Math.random() * 0.3;
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    sizeAttenuation: true
                });
                
                const stars = new THREE.Points(geometry, material);
                this.scene.add(stars);
            }
            
            // Convert HSL to RGB (helper function)
            hslToRgb(h, s, l, targetArray, index) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                targetArray[index] = r;
                targetArray[index + 1] = g;
                targetArray[index + 2] = b;
            }
            
            // Set up event listeners
            setupEventListeners() {
                // Mouse movement
                window.addEventListener('mousemove', (event) => {
                    // Normalize mouse coordinates to -1 to 1 range
                    this.mouse.targetX = (event.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.targetY = -(event.clientY / window.innerHeight) * 2 + 1;
                });
                
                // Touch movement for mobile
                window.addEventListener('touchmove', (event) => {
                    if (event.touches.length > 0) {
                        this.mouse.targetX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                        this.mouse.targetY = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                        event.preventDefault();
                    }
                }, { passive: false });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Mouse wheel for zoom
                window.addEventListener('wheel', (event) => {
                    const zoomSpeed = 0.001;
                    this.targetCameraPosition.z += event.deltaY * zoomSpeed;
                    this.targetCameraPosition.z = Math.max(30, Math.min(120, this.targetCameraPosition.z));
                });
            }
            
            // Hide loading screen
            hideLoadingScreen() {
                const loadingElement = document.getElementById('loading');
                const progressElement = document.getElementById('progress');
                
                // Simulate loading progress
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 10;
                    progressElement.style.width = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(interval);
                        
                        // Fade out loading screen
                        loadingElement.style.transition = 'opacity 0.5s ease';
                        loadingElement.style.opacity = '0';
                        
                        setTimeout(() => {
                            loadingElement.style.display = 'none';
                        }, 500);
                    }
                }, 50);
            }
            
            // Update mouse position with easing
            updateMouse() {
                // Apply easing to mouse movement
                this.mouse.x += (this.mouse.targetX - this.mouse.x) * this.config.mouseEasing;
                this.mouse.y += (this.mouse.targetY - this.mouse.y) * this.config.mouseEasing;
            }
            
            // Update camera position
            updateCamera() {
                // Apply easing to camera movement
                const camera = this.camera;
                const target = this.targetCameraPosition;
                
                camera.position.x += (target.x - camera.position.x) * 0.05;
                camera.position.y += (target.y - camera.position.y) * 0.05;
                camera.position.z += (target.z - camera.position.z) * 0.05;
                
                // Look at the center with a slight offset based on mouse
                camera.lookAt(
                    this.mouse.x * 5,
                    this.mouse.y * 5,
                    0
                );
            }
            
            // Update galaxies rotation and position
            updateGalaxies() {
                const time = this.clock.getElapsedTime();
                
                this.galaxies.forEach((galaxy, index) => {
                    // Rotate the galaxy around its own center
                    galaxy.rotation.x += galaxy.userData.rotationSpeed.x * this.config.rotationSpeed;
                    galaxy.rotation.y += galaxy.userData.rotationSpeed.y * this.config.rotationSpeed;
                    galaxy.rotation.z += galaxy.userData.rotationSpeed.z * this.config.rotationSpeed;
                    
                    // Gentle orbital motion around the scene center
                    const orbitSpeed = 0.02;
                    const orbitRadius = 25;
                    const orbitHeight = 10;
                    
                    galaxy.position.x = galaxy.userData.originalPosition.x + 
                        Math.cos(time * orbitSpeed + galaxy.userData.offset) * 3;
                    galaxy.position.z = galaxy.userData.originalPosition.z + 
                        Math.sin(time * orbitSpeed + galaxy.userData.offset) * 3;
                    galaxy.position.y = galaxy.userData.originalPosition.y + 
                        Math.sin(time * orbitSpeed * 0.7 + galaxy.userData.offset) * 2;
                    
                    // Apply mouse influence
                    galaxy.position.x += this.mouse.x * this.config.mouseInfluence * 10;
                    galaxy.position.y += this.mouse.y * this.config.mouseInfluence * 10;
                });
            }
            
            // Main animation loop
            animate() {
                // Calculate FPS
                const now = performance.now();
                const deltaTime = now - this.lastFrameTime;
                this.lastFrameTime = now;
                this.fps = 1000 / deltaTime;
                
                // Update mouse position
                this.updateMouse();
                
                // Update camera
                this.updateCamera();
                
                // Update galaxies
                this.updateGalaxies();
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
                
                // Increment frame counter
                this.frameCount++;
            }
        }

        // Initialize the galaxy universe when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Check if Three.js is available
            if (typeof THREE === 'undefined') {
                document.getElementById('loading').innerHTML = 
                    '<div>Error: Three.js failed to load. Please check your connection.</div>';
                return;
            }
            
            // Start the application
            const galaxyUniverse = new GalaxyUniverse();
            
            // Make it globally accessible for debugging
            window.galaxyUniverse = galaxyUniverse;
        });
    </script>
</body>
</html>